<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>Balloon Defender</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, #fef3c7 0%, #bae6fd 45%, #93c5fd 100%);
        font-family: "Segoe UI", system-ui, sans-serif;
        color: #0f172a;
        touch-action: none;
      }

      #gameShell {
        width: min(720px, 95vw);
        background: #fff7ed;
        border-radius: 28px;
        padding: 20px;
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.35);
        display: grid;
        gap: 16px;
      }

      header {
        display: grid;
        gap: 6px;
        text-align: center;
      }

      h1 {
        font-size: clamp(1.9rem, 4vw, 2.5rem);
      }

      .subtitle {
        font-size: 0.98rem;
        color: #475569;
      }

      #hud {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 10px;
      }

      .stat {
        background: #e0f2fe;
        border-radius: 16px;
        padding: 10px 14px;
        text-align: center;
        font-weight: 600;
      }

      #arena {
        position: relative;
        width: 100%;
        aspect-ratio: 4 / 5;
        border-radius: 24px;
        background: linear-gradient(180deg, #fde68a 0%, #fbcfe8 100%);
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }

      #overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        text-align: center;
        color: #f8fafc;
      }

      #overlay.hidden {
        display: none;
      }

      .overlay-card {
        background: #1e293b;
        border-radius: 24px;
        padding: 28px;
        max-width: 360px;
        display: grid;
        gap: 12px;
      }

      .overlay-card button {
        border: none;
        padding: 12px 16px;
        border-radius: 999px;
        font-weight: 700;
        cursor: pointer;
        background: #fbbf24;
        color: #0f172a;
      }

      @media (min-width: 640px) {
        #arena {
          aspect-ratio: 16 / 10;
        }
      }
    </style>
  </head>
  <body>
    <div id="gameShell">
      <header>
        <h1>Balloon Defender</h1>
        <p class="subtitle">Tap the balloons before they float away!</p>
      </header>

      <section id="hud">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Lives: <span id="lives">5</span></div>
        <div class="stat">Level: <span id="level">1</span></div>
        <div class="stat">Best: <span id="best">0</span></div>
      </section>

      <div id="arena">
        <canvas id="gameCanvas" width="800" height="500"></canvas>
      </div>
    </div>

    <div id="overlay">
      <div class="overlay-card">
        <h2>Balloon Defender</h2>
        <p>Tap the balloons before they reach the top. Don’t let too many escape!</p>
        <button id="startButton">Start</button>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const livesEl = document.getElementById("lives");
      const levelEl = document.getElementById("level");
      const bestEl = document.getElementById("best");
      const overlay = document.getElementById("overlay");
      const startButton = document.getElementById("startButton");

      const balloonColors = ["#f87171", "#fbbf24", "#34d399", "#60a5fa", "#a78bfa"];
      const state = {
        running: false,
        score: 0,
        lives: 5,
        speed: 1.2,
        spawnTimer: 0,
        spawnInterval: 1.4,
        elapsed: 0,
        best: Number(localStorage.getItem("balloonDefenderBest") || 0),
      };

      const balloons = [];
      const clouds = Array.from({ length: 10 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height * 0.6,
        size: Math.random() * 30 + 30,
        drift: Math.random() * 0.4 + 0.2,
      }));

      bestEl.textContent = state.best;

      function resetGame() {
        state.running = true;
        state.score = 0;
        state.lives = 5;
        state.speed = 1.2;
        state.spawnTimer = 0;
        state.spawnInterval = 1.4;
        state.elapsed = 0;
        balloons.length = 0;
        overlay.classList.add("hidden");
        updateHud();
      }

      function updateHud() {
        scoreEl.textContent = state.score;
        livesEl.textContent = state.lives;
        levelEl.textContent = Math.max(1, Math.floor(state.score / 30) + 1);
        bestEl.textContent = state.best;
      }

      function spawnBalloon() {
        const radius = Math.random() * 16 + 26;
        balloons.push({
          x: Math.random() * (canvas.width - radius * 2) + radius,
          y: canvas.height + radius + Math.random() * 50,
          radius,
          speed: state.speed + Math.random() * 0.8,
          color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
        });
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "#bae6fd");
        gradient.addColorStop(1, "#fef3c7");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        clouds.forEach((cloud) => {
          ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          ctx.beginPath();
          ctx.ellipse(cloud.x, cloud.y, cloud.size, cloud.size * 0.6, 0, 0, Math.PI * 2);
          ctx.ellipse(cloud.x + cloud.size * 0.6, cloud.y + cloud.size * 0.1, cloud.size * 0.8, cloud.size * 0.5, 0, 0, Math.PI * 2);
          ctx.ellipse(cloud.x - cloud.size * 0.5, cloud.y + cloud.size * 0.1, cloud.size * 0.7, cloud.size * 0.4, 0, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      function drawBalloon(balloon) {
        ctx.fillStyle = balloon.color;
        ctx.beginPath();
        ctx.ellipse(balloon.x, balloon.y, balloon.radius, balloon.radius * 1.15, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(15, 23, 42, 0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(balloon.x, balloon.y + balloon.radius * 1.1);
        ctx.lineTo(balloon.x, balloon.y + balloon.radius * 1.7);
        ctx.stroke();
      }

      function updateBalloons() {
        for (let i = balloons.length - 1; i >= 0; i--) {
          balloons[i].y -= balloons[i].speed;
          if (balloons[i].y + balloons[i].radius < 0) {
            balloons.splice(i, 1);
            state.lives -= 1;
          }
        }
      }

      function handleTap(x, y) {
        for (let i = balloons.length - 1; i >= 0; i--) {
          const balloon = balloons[i];
          const distance = Math.hypot(x - balloon.x, y - balloon.y);
          if (distance <= balloon.radius) {
            balloons.splice(i, 1);
            state.score += 5;
            updateHud();
            return;
          }
        }
      }

      function endGame() {
        state.running = false;
        if (state.score > state.best) {
          state.best = state.score;
          localStorage.setItem("balloonDefenderBest", state.best);
        }
        updateHud();
        overlay.querySelector("h2").textContent = "Nice Try!";
        overlay.querySelector("p").textContent = `Score: ${state.score} • Best: ${state.best}`;
        startButton.textContent = "Play Again";
        overlay.classList.remove("hidden");
      }

      let lastTime = 0;

      function gameLoop(timestamp) {
        const delta = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        drawBackground();

        clouds.forEach((cloud) => {
          cloud.x += cloud.drift * 0.2;
          if (cloud.x - cloud.size > canvas.width) {
            cloud.x = -cloud.size;
          }
        });

        if (state.running) {
          state.elapsed += delta;
          const difficultyLevel =
            Math.floor(state.score / 30) + Math.floor(state.elapsed / 12);
          state.speed = 1.2 + difficultyLevel * 0.25;
          state.spawnInterval = Math.max(0.45, 1.4 - difficultyLevel * 0.08);

          state.spawnTimer += delta;
          if (state.spawnTimer >= state.spawnInterval) {
            state.spawnTimer = 0;
            spawnBalloon();
          }

          updateBalloons();

          if (state.lives <= 0) {
            endGame();
          }
        }

        balloons.forEach(drawBalloon);

        requestAnimationFrame(gameLoop);
      }

      function getCanvasPosition(event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (event.clientX - rect.left) * scaleX,
          y: (event.clientY - rect.top) * scaleY,
        };
      }

      canvas.addEventListener("click", (event) => {
        if (!state.running) return;
        const position = getCanvasPosition(event);
        handleTap(position.x, position.y);
      });

      canvas.addEventListener(
        "touchstart",
        (event) => {
          event.preventDefault();
          if (!state.running) return;
          const touch = event.changedTouches[0];
          const position = getCanvasPosition(touch);
          handleTap(position.x, position.y);
        },
        { passive: false },
      );

      overlay.addEventListener("click", () => resetGame());
      overlay.addEventListener(
        "touchstart",
        (event) => {
          event.preventDefault();
          resetGame();
        },
        { passive: false },
      );
      startButton.addEventListener("click", resetGame);

      gameLoop();
    </script>
  </body>
</html>
